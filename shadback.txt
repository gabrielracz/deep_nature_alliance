#version 330
#pragma optionNV(unroll all)

// Attributes passed from the vertex shader
in vec3 color_interp;
in vec3 position_interp;
in vec2 uv_interp;
in vec3 normal_interp;
in vec3 light_pos;

struct Light {
    vec3 position;
    float ambient_strength;
    vec4 color;
    vec4 ambient_color;
    vec3 direction;
    float spread;
};

in Light lights[3];
flat in int num_lights;

flat in mat4 light_view_matrix2;

uniform sampler2D texture_map;
uniform sampler2D normal_map; // Normal map
uniform sampler2D shadow_map; // Normal map

uniform float texture_repetition;
uniform float normal_map_repetition;



// uniform vec4 light_col;
uniform float specular_power;
uniform float diffuse_strength;
uniform float amb;
uniform vec4 ambcol;
uniform float timer;


float phong_specular(vec3 lv, vec3 n) {
	vec3 v = vec3(0,0,0);
    vec3 r = -lv + 2*(dot(lv, n)*n);
	vec3 vv = normalize(v - position_interp);
    float spec = max(0.0, dot(vv, r));
    spec = pow(spec, specular_power/4); //4x less intense than blinn-phong
    return spec;

}

float blinnphong_specular(vec3 lv, vec3 n) {
	vec3 v = vec3(0,0,0);
	vec3 vv = normalize(v - position_interp);
	vec3 h = normalize((vv+lv)/2); 

    float spec = max(0.0, dot(n,h)); 
    spec = pow(spec, specular_power);

    return spec;
}


vec4 lighting(vec4 pixel, int i, vec3 lv, vec3 n) {

	float diffuse = max(0.0, dot(n,lv));
    float spec = blinnphong_specular(lv, n);
    // float spec = phong_specular(lv, n);
    if(diffuse == 0.0 || specular_power == 0.0) {spec = 0.0;}

    return diffuse_strength*diffuse*lights[i].color*pixel + lights[i].ambient_strength*lights[i].ambient_color*pixel + spec*lights[i].color;
}

float shadow(int i){
// Transform the fragment's position from world space to light space
   vec4 fragPosLightSpace = light_view_matrix2 * vec4(position_interp, 1.0);
   // Sample the shadow map
   float closestDepth = texture(shadow_map, fragPosLightSpace.xy).r;
   // The depth value in the shadow map is in linear range between [0,1]. Re-transform back to original value
   closestDepth *= fragPosLightSpace.z;
   // Now get current linear depth as the length between the fragment and light position
   float currentDepth = length(fragPosLightSpace);
   // Now test for shadows
   float bias = 0.05;
   float shadow = currentDepth - bias > closestDepth ? 0.5 : 1.0;
   return shadow;
}

void main() 
{
    vec4 accumulator = vec4(0.0, 0.0, 0.0, 0.0);
    for(int i = 0; i < num_lights; i++) {
        vec3 light_vector = normalize(lights[i].position - position_interp);                                     // light direction, object position as origin
        vec3 n_bump = normalize(texture(normal_map, uv_interp * normal_map_repetition).rgb*2.0 - 1.0);  // sample normal map
        vec3 normal = normalize(normal_interp + n_bump) ;                                               // displace fragment normal by bump
        vec4 pixel = texture(texture_map, uv_interp * texture_repetition);                              // sample color texture

        // vec4 pixel = vec4(color_interp, 1.0);                                                                       // mix with underlying model color
        vec4 lit_pixel = lighting(pixel, i, light_vector, normal);
        // vec4 lit_pixel = pixel;
        accumulator += lit_pixel;
    }
    gl_FragColor = accumulator ;
}

#version 330 core
#pragma optionNV(unroll all)

layout (location = 0) in vec3 vertex;
layout (location = 1) in vec3 normal;
layout (location = 2) in vec3 color;
layout (location = 3) in vec2 uv;
layout (location = 4) in vec3 tangent;

// Uniform (global) buffer
uniform mat4 world_mat;
uniform mat4 view_mat;
uniform mat4 projection_mat;
uniform mat4 normal_mat;
uniform vec3 light_pos_world;

// Attributes forwarded to the fragment shader
out vec3 position_interp;
out vec2 uv_interp;
out vec3 light_pos;
out vec3 color_interp;
out vec3 normal_interp;

out float test;

struct Light {
    vec3 position;
    float ambient_strength;
    vec4 color;
    vec4 ambient_color;
    vec3 direction;
    float spread;
};

out Light lights[3];
flat out int num_lights;
flat out mat4 light_view_matrix2;

layout(std140) uniform LightsBlock {
    Light world_lights[3];
};
uniform int num_world_lights;
uniform mat4 light_view_matrix;

void main()
{
    vec4 position = view_mat * world_mat * vec4(vertex, 1.0);
    gl_Position = projection_mat * position;

    // Define vertex tangent, bitangent and normal (TBN)
    // These are used to create the tangent space transformation matrix
    vec3 vertex_normal = vec3(normal_mat * vec4(normal, 0.0));
    vec3 vertex_tangent_ts = vec3(normal_mat * vec4(tangent, 0.0));
    vec3 vertex_bitangent_ts = cross(vertex_normal, vertex_tangent_ts);

    // Send tangent space transformation matrix to the fragment shader
    mat3 TBN_mat = transpose(mat3(vertex_tangent_ts, vertex_bitangent_ts, vertex_normal));

    position_interp = TBN_mat * vec3(position);
    normal_interp = TBN_mat * vertex_normal;
    for(int i = 0; i < num_world_lights; i++) {
        lights[i].position         = TBN_mat * vec3(view_mat * vec4(world_lights[i].position, 1.0));
        lights[i].color            = world_lights[i].color;
        lights[i].ambient_color    = world_lights[i].ambient_color;
        lights[i].ambient_strength = world_lights[i].ambient_strength;
    }
    num_lights = num_world_lights;


    color_interp = color;
    uv_interp = uv; 
    light_view_matrix2 = light_view_matrix;
}

